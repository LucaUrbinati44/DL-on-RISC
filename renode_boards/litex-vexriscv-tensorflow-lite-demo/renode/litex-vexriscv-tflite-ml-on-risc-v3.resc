# sysbus - a peripheral that is always available and does not have to be explicitly defined in the .repl file
# If you want to access a peripheral of your machine, you need to use sysbus.<peripheral_name>. 
# You can use the "using" command to set a default prefix in order to avoid the "sysbus." prefix when accessing a peripheral.
using sysbus

# The $ sign represents a variable definition.
# The $var?= is indicates a default value if the variable is not set.
# The @ sign represents a path to a file
$zephyr_elf?=@../tensorflow/tensorflow/lite/micro/tools/make/gen/zephyr_vexriscv_x86_64/ml_on_risc/build/zephyr/zephyr.elf
$input_data?=@/mnt/c/Users/Work/Desktop/deepMIMO/RIS/renode_boards/litex-vexriscv-tensorflow-lite-demo/renode/test_set_small.resd

# Add a machine to run. If you don’t give it a custom name, will be indexed from 0 (and thus called machine-0).
# This command also switches the Monitor’s context to this new machine.
mach create

# Once a machine is created, it contains only one peripheral - the system bus called simply sysbus. 
# There is no memory or CPU, so the machine is not yet ready to execute any code.
# Load a local predefined platform
# The Monitor gives you access to two special variables: $ORIGIN and $CWD.
# Use $ORIGIN for a path that is relative to the currently executed Renode script.
# Use $CWD for a path that is relative to the current working directory.
machine LoadPlatformDescription $ORIGIN/litex-vexriscv-tflite-ml-on-risc-v3.repl

# or load a predefined Renode platflorm.
# The PATH contains the Renode installation directory, so the platform files distributed with Renode can be included with "using"
# using "platforms/cpus/miv.repl"

# In addition to the default window called Monitor, open a new window for different analyzers (e.g., UART). Uncomment if GUI is enabled.
showAnalyzer uart

# Apart from the standard logger configuration, you can enable logging of accesses to specific peripherals.
#sysbus LogPeripheralAccess sysbus.uart0

# Create a trace of every function executed by the binary.
#sysbus.cpu LogFunctionNames true ["filter1 filter2"] true

# A macro enables you to encapsulate fragments of your script and execute them easily with the "runMacro” command.
# The macro need to be surrounded by the triple quotes sign.


macro reset
"""
    # Upload the software onto the platform. Load the binary (the .elf file)
    sysbus LoadELF $zephyr_elf

    # Upload resd file into the virtual UART
    feeder FeedDataFromRESD $input_data mode=Normal channelId=0 sampleOffsetTime=2500000000
"""

runMacro $reset